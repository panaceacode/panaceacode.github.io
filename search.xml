<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Alg.1 Two Sum</title>
    <url>/panaceacode.github.io/2020/04/04/Alg-1-Two-Sum/</url>
    <content><![CDATA[<p><em>AlgoExpert is a cool place to practice your algorithm skill, and you can visit <a href="https://www.algoexpert.io/product">https://www.algoexpert.io/product</a> to find what you can get.</em><br><br><em>Two Sum from algoexpert.io, basically 3 ways to solve this problem：</em><br><br><em>1. Brute Force</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoNumberSum(<span class="keyword">int</span>[] array, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] + array[j] == targetSum) &#123;</span><br><span class="line">                    ans[<span class="number">0</span>] = array[i];</span><br><span class="line">                    ans[<span class="number">1</span>] = array[j];</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n^2); Space complexity: O(1)<br><em>2. Use a set, improve time complexity by adding extra space comlexcity.</em> <br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoNumberSum(<span class="keyword">int</span>[] array, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = targetSum - array[i];</span><br><span class="line">            <span class="keyword">if</span> (set.contains(remain)) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] = array[i];</span><br><span class="line">                ans[<span class="number">1</span>] = targetSum - ans[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n); Space complexity: O(n)<br><em>3. Two pointers, this method works only if the array is sorted. In this problem, we have to sort the array first.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoNumberSum(<span class="keyword">int</span>[] array, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[left] + array[right] == targetSum) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;array[left], array[right]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (array[left] + array[right] &lt; targetSum) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity:O(nlogn)(since we need to sort this array first); Space complexity:O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.10 Palindrome Check</title>
    <url>/panaceacode.github.io/2020/04/07/Alg-10-Palindrome-Check/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>A palindrome is a string that’s written the same forward and backward. For this problem, we need to write a function to determine whether a string is palindrome</em><br><br><em>The code implementation is pretty straightforward, we use two pointers, they point to the start and end of the string. Then, we check if the characters are the same until we reach the midpoint of the string.</em><br><br><em>Here is the code implementation</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(left) != str.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n); Space complexity: O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.11 Caesar Cipher Encryptor</title>
    <url>/panaceacode.github.io/2020/04/08/Alg-11-Caesar-Cipher-Encryptor/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>This is a easy string-related problem, given a string and a number k, we need to shift every character in the string k positions in the alphabet list.</em><br><br><em>Basically, we iterate this string, get each expecting character after we shift k positions. According to the ASCII code, assume current character’s ASCII is c, the transformed ASCII is c - ‘a’ + k, then we get the remainder, answer will be ‘a’ + (c - ‘a’ + k) % (‘z’ - ‘a’ + 1).</em><br><br><em>Here is the code implementation:</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">caesarCypherEncryptor</span><span class="params">(String str, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = str.charAt(i) - <span class="string">&#x27;a&#x27;</span> + key;</span><br><span class="line">            <span class="keyword">int</span> trans = diff % (<span class="string">&#x27;z&#x27;</span> - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>)(trans + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            ans.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n); Space complexity: O(n)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.12 Run-Length Encoding</title>
    <url>/panaceacode.github.io/2020/04/08/Alg-12-Run-Length-Encoding/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>Here is the introduction of Run_Length Encoding: <a href="https://en.wikipedia.org/wiki/Run-length_encoding">https://en.wikipedia.org/wiki/Run-length_encoding</a></em><br><br><em>Code implementation</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">runLengthEncoding</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> currentLength = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = string.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> prev = string.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cur != prev || currentLength == <span class="number">9</span>) &#123;</span><br><span class="line">                result.append(Integer.toString(currentLength));</span><br><span class="line">                result.append(prev);</span><br><span class="line">                currentLength = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentLength++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result.append(Integer.toString(currentLength));</span><br><span class="line">        result.append(string.charAt(string.length() - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><em>Pay attention to the edge condition, after we finish the iteration, there are two conditions: 1. the last character is different from its preceding character, or 2. the last character is the same as the previous one. We need to append another integer and character under both conditions.</em><br><br>Time complexity: O(n); Space complexity: O(n)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.13 Longest Palindromic Substring</title>
    <url>/panaceacode.github.io/2020/04/08/Alg-13-Longest-Palindromic-Substring/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>Previous problem explains what is a palindrome string, in this problem, we will write a function to find out the longest palindromic substring within a given string.</em><br><br><em>In the solution, we consider each character as a center of a potential palindrome, however, when a string contains even number elements, the center should contains 2 characters. So, we write a function to find longest palindrome given a center.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findLPS(String str, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; str.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(left) != str.charAt(right)) <span class="keyword">break</span>;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Now, we iterate the string, find its longest palindromic substring</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindromicSubstring</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] odd = findLPS(str, i - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span>[] even = findLPS(str, i - <span class="number">1</span>, i);</span><br><span class="line">            <span class="keyword">int</span>[] longest = (odd[<span class="number">1</span>] - odd[<span class="number">0</span>]) &gt; (even[<span class="number">1</span>] - even[<span class="number">0</span>]) ? odd : even;</span><br><span class="line">            ans = (longest[<span class="number">1</span>] - longest[<span class="number">0</span>]) &gt; (ans[<span class="number">1</span>] - ans[<span class="number">0</span>]) ? longest : ans;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> str.substring(ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n^2); Space complexity: O(n)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.14 Group Anagrams</title>
    <url>/panaceacode.github.io/2020/04/09/Alg-14-Group-Anagrams/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>Anagrams are strings made up of exactly the same letters, in this problem, we need to write a function that takes in an array of strings and groups anagrams together. Here is an example:</em><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Algorithm/Group%20Anagrams.png" width="73%" height="73%" align="middle" /><br><br><em>In the solution, we iterate the original string array, we use Arrays.sort() to sort each string, then store the sorted string and original string into a map. Here is the code implementation:</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(List&lt;String&gt; words) &#123;</span><br><span class="line">    </span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; anagrams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] charArray = word.toCharArray();</span><br><span class="line">            Arrays.sort(charArray);</span><br><span class="line">            String sortedWord = <span class="keyword">new</span> String(charArray);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (anagrams.containsKey(sortedWord)) anagrams.get(sortedWord).add(word);</span><br><span class="line">            <span class="keyword">else</span> anagrams.put(sortedWord, <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(word)));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; value : anagrams.values()) &#123;</span><br><span class="line">            ans.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>For time complexity: we need to sort each string, w<em>n</em>logn; Space complexity is pretty straightforward, wn. (w is the number of words, n is the length of the longest string)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.15 Valid IP Addresses</title>
    <url>/panaceacode.github.io/2020/04/09/Alg-15-Valid-IP-Addresses/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>Given a string of length 12 or smaller, consists of only digits. We need to write a function to find out all the potential IP addresses by inserting 3 ‘.’ to each address. In the code implementation, we simply iterate the original string and enumerate all the combinations. The key part is how we design a function to recognize a valid IP addess.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(string);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> string.equals(Integer.toString(num));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em>In this ‘isValid’ function, we return ‘string.equals(Integer.toString(num))’ in order to avoid situations like ‘01’, ‘001’, ‘00’, etc. If we find a valid IP, we have to build up the result.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">join</span><span class="params">(String[] validIp)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(validIp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; validIp.length; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            sb.append(validIp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em>Now, we can do our iteration and enumerate all the combinations.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">validIPAddresses</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = string.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Math.min(len, <span class="number">4</span>); i++)&#123;</span><br><span class="line">            String[] validIp = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">            validIp[<span class="number">0</span>] = string.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (!isValid(validIp[<span class="number">0</span>])) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + Math.min(len - i, <span class="number">4</span>); j++) &#123;</span><br><span class="line">                validIp[<span class="number">1</span>] = string.substring(i, j);</span><br><span class="line">                <span class="keyword">if</span> (!isValid(validIp[<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; j + Math.min(len - j, <span class="number">4</span>); k++) &#123;</span><br><span class="line">                    validIp[<span class="number">2</span>] = string.substring(j, k);</span><br><span class="line">                    validIp[<span class="number">3</span>] = string.substring(k);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (isValid(validIp[<span class="number">2</span>]) &amp;&amp; isValid(validIp[<span class="number">3</span>])) &#123;</span><br><span class="line">                        ans.add(join(validIp));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(1); Space complexity: O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.16 Reverse Words In String</title>
    <url>/panaceacode.github.io/2020/04/09/Alg-16-Reverse-Words-In-String/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>In this problem, given a string of words seperated by one or more whitespaces. We need to write a function reverse these words. Basically, the idea is seperate all the words by the whitespaces. Then, we simply reverse them. Here is the implementation:</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWordsInString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> curStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = string.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c  == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                words.add(string.substring(curStart, i));</span><br><span class="line">                words.add(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                curStart = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        words.add(string.substring(curStart));</span><br><span class="line">        Collections.reverse(words);</span><br><span class="line">    <span class="keyword">return</span> String.join(<span class="string">&quot;&quot;</span>, words);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><em>Another way is to first reverse all the characters within this string, then we reverse each string back.</em><br><br>Time complexity: O(n); Space complexity: O(n)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.17 Longest Substring Without Duplication</title>
    <url>/panaceacode.github.io/2020/04/10/Alg-17-Longest-Substring-Without-Duplication/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>In this problem, we need to write a function to find out the longest substring without any duplicate characters.</em><br><br><em>We iterate the original string and use a map to record the characters and their corresponding positions. Array “longest” stores the index of the current longest substring, “startIdx” is the current start point of a potential longest substring. When we get to a character, we determine whether we have met it before and if it appears after the current head, we can update the current “startIdx” according to this rule. Then we can update the “longest” by comparing the lengths of current potential longest substring and “longest”. Here is the code implementation:</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestSubstringWithoutDuplication</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] longest = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> startIdx = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Use a map to record the characters and its corresponding position</span></span><br><span class="line">        Map&lt;Character, Integer&gt; table = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// If the character we have Encountered before</span></span><br><span class="line">            <span class="keyword">if</span> (table.containsKey(str.charAt(i))) &#123;</span><br><span class="line">                <span class="comment">// If this character appears after the current head,</span></span><br><span class="line">                <span class="comment">// we update the head</span></span><br><span class="line">                <span class="keyword">if</span> (table.get(str.charAt(i)) + <span class="number">1</span> &gt;= startIdx) &#123;</span><br><span class="line">                    startIdx = table.get(str.charAt(i)) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            table.put(str.charAt(i), i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Update the current longest substring</span></span><br><span class="line">            <span class="keyword">if</span> (i - startIdx + <span class="number">1</span> &gt; longest[<span class="number">1</span>] - longest[<span class="number">0</span>]) &#123;</span><br><span class="line">                longest[<span class="number">0</span>] = startIdx;</span><br><span class="line">                longest[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> str.substring(longest[<span class="number">0</span>], longest[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n); Space complexity:O(n)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.2 Validate Subsequence</title>
    <url>/panaceacode.github.io/2020/04/04/Alg-2-Validate-Subsequence/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>Write a function that determines whether “sequence” array is a subsequence of “array” array. For example, [1, 6, -1, 10] is a subsequence of [5, 1, 22, 25, 6, -1, 8, 10]</em><br><br><em>First, we iterate “array”, at the same time, we use a pointer to track the current position of “sequence”. If the value of “array” equals the value of current “sequence”, “sequence”‘s pointer will increment by 1. When we finish the iteration, we only need to compare the length of “sequence” and “sequence”‘s pointer.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidSubsequence</span><span class="params">(List&lt;Integer&gt; array, List&lt;Integer&gt; sequence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == sequence.size()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (array.get(i) == sequence.get(j)) j++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> j == sequence.size();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n); Space complexity: O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.3 Remove Duplicates From Linked List</title>
    <url>/panaceacode.github.io/2020/04/04/Alg-3-Remove-Duplicates-From-Linked-List/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>GIven a singly linked list, their nodes are sorted with respect to their value. Write a function to remove the nodes with duplicate values.</em><br><br><em>This method is pretty straightforward</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkedList <span class="title">removeDuplicatesFromLinkedList</span><span class="params">(LinkedList linkedList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        LinkedList current = linkedList;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LinkedList next = current.next;</span><br><span class="line">            <span class="keyword">while</span> (next != <span class="keyword">null</span> &amp;&amp; current.value == next.value) &#123;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = next;</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n); Space complexity: O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Linked Lists</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.4 Kadane&#39;s Algorithm</title>
    <url>/panaceacode.github.io/2020/04/05/Alg-4-Kadane-s-Algorithm/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>In this problem, we have to write a function to get a given array’s maximum sum of its subarray. So, in this case, Kadane’s Algorithm would be an efficient option for this one.</em><br><br><em>Assume we have an non-empty array, “array”, first, we need to iterate this array,  use a variable “currentSum” to record the current maximum sum. Obviouly, the maximum sum would be either the current element array[i] or ans + array[i]. We almost finish this problrm here, the last thing we need to do is to find the biggest “currentSum” while we iterate this array.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kadanesAlgorithm</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> currentSum = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            currentSum = Math.max(array[i], currentSum + array[i]);</span><br><span class="line">            ans = Math.max(currentSum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n); Space complexity: O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.5 Bubble Sort</title>
    <url>/panaceacode.github.io/2020/04/05/Alg-5-Bubble-Sort/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>Bubble Sort is probably the first sorting algorithm we learned when we study algorithm. In this problem, we will use Bubble Sort to sort the given arrays. What’s more, we will find potential method to make Bubble Sort more efficient.</em><br><br><em>First, in this problem and future problems which are related to sorting algorithm, we may need to swap elements.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><em>Then, we will apply Bubble Sort to solve this problem. Basically, in Bubble Sort, we need to iterate the original array n times which is its length to determine each element’s position. Here, we will use a little trick to end some unnecessary iterations. In a certain iteration, if there is no swap, it means all the elements are in the expecting positions.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> array;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n^2); Space complexity: O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.6 Insertion Sort</title>
    <url>/panaceacode.github.io/2020/04/05/Alg-6-Insertion-Sort/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br ><br><em>We apply Insertion Sort to sort the given arrays. For the Insertion Sort, we basically separate the original array into 2 parts, “ordered” one and “disordered” one. First, we iterate the array from the second element if the length of the original array is no less than 2. Tha idea is we pick a element from the “disordered” collection, find the expecting position in the “ordered” one, then insert the element into the “ordered” one.</em><br><br><em>Here are the code implementations, two ways are basically apply the same conception.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = array[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; value) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + <span class="number">1</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n^2); Space complexity: O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i - <span class="number">1</span>] &gt; array[i]) &#123;</span><br><span class="line">                    swap(array, i, i - <span class="number">1</span>);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n^2); Space complexity: O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.7 Selection Sort</title>
    <url>/panaceacode.github.io/2020/04/06/Alg-7-Selection-Sort/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>Selection Sort is pretty much like the Insertion Sort. We divide the original array into two parts, “ordered” and “disordered”. But for Selection Sort, we will find the smallest number in the “disordered” part, and insert that number into “ordered” one. That’s why we called it Selection Sort.</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n^2); Space complexity: O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.8 Quick Sort</title>
    <url>/panaceacode.github.io/2020/04/07/Alg-8-Quick-Sort/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>Quick Sort is a widely-used sorting algorithm, it borrows the strategy, “Divide and Conquer”, to divide the original array into 2 parts and do the sorting recursively. Here are the steps of Quick Sort:</em><br><br><em>1. Select a pivot, there are a lot of strategies to pick a pivot in order to make sure we can seperate the original array evenly. But here, we simply pick the first elements as pivots</em><br><br><em>2. Divide the original array into 2 parts, each element of the first one is less than or equals pivot, each element in the second one is greater than pivot</em><br><br><em>3. Repeat 1 and 2 on the subarrays</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortHelper</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = array[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[left] &gt; pivot &amp;&amp; array[right] &lt; pivot) &#123;</span><br><span class="line">                swap(array, left, right);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (array[left] &lt;= pivot) left++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (array[right] &gt;= pivot) right--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, right, startIndex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Here&#x27;s a optimization: In order to run faster, we always want run the subarray</span></span><br><span class="line">        <span class="comment">// with shorter length, therefore, the memory of call stack will be released.</span></span><br><span class="line">        <span class="keyword">if</span> (right - <span class="number">1</span> - startIndex &lt; endIndex - right - <span class="number">1</span>) &#123;</span><br><span class="line">            quickSortHelper(array, startIndex, right - <span class="number">1</span>);</span><br><span class="line">            quickSortHelper(array, right + <span class="number">1</span>, endIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quickSortHelper(array, right + <span class="number">1</span>, endIndex);</span><br><span class="line">            quickSortHelper(array, startIndex, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        quickSortHelper(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since we do the sorting recursively, the space complexity is O(logn)<br><br>For the time complexity, if we can’t seperate the arrays evenly, under its worst condition, the time complexity will be O(n^2). However, under its best and average conditions, the time complexity will be O(logn).</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>Alg.9 Merge Sort</title>
    <url>/panaceacode.github.io/2020/04/07/Alg-9-Merge-Sort/</url>
    <content><![CDATA[<p><em>From algoexpert.io</em><br><br><em>For the Merge Sort, it also uses the conception “Divide and Conquer”. We simply divide the original arrays evenly recursively, then merge them. So, in Merge Sort algorithm, the time and space complexity are pretty stable.</em><br><br><em>Here is the code implementation:</em><br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] leftSubArray = Arrays.copyOfRange(array, <span class="number">0</span>, array.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[] rightSubArray = Arrays.copyOfRange(array, array.length / <span class="number">2</span>, array.length);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> mergeTwoArrays(mergeSort(leftSubArray), mergeSort(rightSubArray));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeTwoArrays(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length + arr2.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &lt;= arr2[j]) ans[k++] = arr1[i++];</span><br><span class="line">            <span class="keyword">else</span> ans[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length) ans[k++] = arr1[i++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (j &lt; arr2.length) ans[k++] = arr2[j++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Time complexity: O(logn); Space complexity: O(logn)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>Belfast</title>
    <url>/panaceacode.github.io/2019/12/21/Belfast/</url>
    <content><![CDATA[<h1 id="2019-12-19"><a href="#2019-12-19" class="headerlink" title="2019/12/19"></a><em>2019/12/19</em></h1><p><em>第一天计划去贝尔法斯特玩，我垚坚持要买早班飞机，结果早上起不来，于是就有了两张机票</em> <br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/ticket.jpg" width="50%" height="35%" align="bottom" /><br></p>
<p><em>在贝法第一天去了泰坦尼克博物馆，晚上去吃了一个很不错的汉堡。当天晚上有个圣诞集市，贝法的景色还是很不错的</em> <br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/titanic.jpg" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/titanic1.jpg" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/19.jpg" width="50%" height="50%" align="bottom" /><br></p>
<h1 id="2019-12-20"><a href="#2019-12-20" class="headerlink" title="2019/12/20"></a><em>2019/12/20</em></h1><p><em>今天是权游主题观光！！！吃到个超棒的chowder！！！</em> <br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/got1.JPG" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/got2.JPG" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/got3.JPG" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/got4.JPG" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/got5.JPG" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/got6.JPG" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/got7.JPG" width="50%" height="50%" align="bottom" /><br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/got8.JPG" width="50%" height="50%" align="bottom" /><br></p>
<h1 id="2019-12-21"><a href="#2019-12-21" class="headerlink" title="2019/12/21"></a><em>2019/12/21</em></h1><p><em>最后一天简单逛了一下贝法的女王大学和市政厅，打道回府～</em> <br><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Belfast/belfast.JPG" width="50%" height="50%" align="bottom" /><br></p>
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Travel</tag>
        <tag>Belfast</tag>
      </tags>
  </entry>
  <entry>
    <title>Edinburgh</title>
    <url>/panaceacode.github.io/2019/12/18/Edinburgh/</url>
    <content><![CDATA[<h1 id="2019-12-17"><a href="#2019-12-17" class="headerlink" title="2019/12/17"></a><em>2019/12/17</em></h1><p><em>出发去英国</em><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Edinburgh/ticket.jpg" width="50%" height="35%" align="middle" /><br></p>
<p><em>落地伦敦，提前复习了一遍哈利波特，特意到King’s Cross转车</em><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Edinburgh/kingscross.jpg" width="50%" height="50%" align="middle" /><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Edinburgh/kingscross1.jpg" width="50%" height="50%" align="middle" /><br></p>
<p><em>出发去爱丁堡，开心！</em><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Edinburgh/trainTicket.jpg" width="50%" height="35%" align="middle" /><br></p>
<h1 id="2019-12-18"><a href="#2019-12-18" class="headerlink" title="2019/12/18"></a><em>2019/12/18</em></h1><p><em>在爱丁堡的第一天</em><br><img src="https://blog-lzr.oss-cn-shanghai.aliyuncs.com/Edinburgh/edinburgh.jpg" width="50%" height="50%" align="middle" /></p>
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Travel</tag>
        <tag>Edinburgh</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH连接GitHub账号</title>
    <url>/panaceacode.github.io/2019/10/19/SSH%E8%BF%9E%E6%8E%A5GitHub%E8%B4%A6%E5%8F%B7/</url>
    <content><![CDATA[<p>简单介绍一下用SSH连接GitHub的流程<a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">参考链接</a></p>
<h3 id="1-Mac环境下检查一下已存在的-SSH-Keys"><a href="#1-Mac环境下检查一下已存在的-SSH-Keys" class="headerlink" title="1. Mac环境下检查一下已存在的 SSH Keys"></a><em>1. Mac环境下检查一下已存在的 SSH Keys</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>
<p>可能的keys：id_rsa.pub、id_ecdsa.pub、id_ed25519.pub<br><br></p>
<h3 id="2-生成新的-SSH-keys"><a href="#2-生成新的-SSH-keys" class="headerlink" title="2. 生成新的 SSH keys"></a><em>2. 生成新的 SSH keys</em></h3><p>在Terminal中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果不支持ed25519，可以用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>生成一个新的ssh key，用邮箱作为label</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Generating public/private ed25519 key pair.</span><br></pre></td></tr></table></figure>
<p>Press enter</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Enter a file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/you/.ssh/id_ed25519): [Press enter]</span><br></pre></td></tr></table></figure>
<p>可设置passphrase</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Enter passphrase (empty <span class="keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line">&gt; Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure>
<br>

<h3 id="3-将-SSH-keys加入ssh-agent"><a href="#3-将-SSH-keys加入ssh-agent" class="headerlink" title="3. 将 SSH keys加入ssh-agent"></a><em>3. 将 SSH keys加入ssh-agent</em></h3><p>启动ssh-agent</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">&gt; Agent pid 59566</span><br></pre></td></tr></table></figure>
<p>如果你是macOS Sierra 10.12.2或更高，需要修改~/.ssh/config文件，才能自动把keys加载到ssh-agent并在keychain中储存passphrases</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ open ~/.ssh/config</span><br><span class="line">&gt; The file /Users/you/.ssh/config does not exist.</span><br></pre></td></tr></table></figure>
<p>如果该文件不存在，创建该文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch ~/.ssh/config</span><br></pre></td></tr></table></figure>
<p>如果你使用默认路径和命名，修改为如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host *</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>
<p>将SSH私钥加入到ssh-agent，并在keychain中储存passphrase</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-add -K ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>
<br>

<h3 id="4-将-SSH-key加入到-GitHub账号中"><a href="#4-将-SSH-key加入到-GitHub账号中" class="headerlink" title="4. 将 SSH key加入到 GitHub账号中"></a><em>4. 将 SSH key加入到 GitHub账号中</em></h3><p>拷贝SSH公钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pbcopy &lt; ~/.ssh/id_ed25519.pub</span><br><span class="line"><span class="comment"># Copies the contents of the id_ed25519.pub file to your clipboard</span></span><br></pre></td></tr></table></figure>
<p>进入GitHub Settings =&gt; “SSH and GPG keys”，新建并添加新key<br><br></p>
<h3 id="5-测试连接"><a href="#5-测试连接" class="headerlink" title="5. 测试连接"></a><em>5. 测试连接</em></h3><p>在Terminal中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line"><span class="comment"># Attempts to ssh to GitHub</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; The authenticity of host <span class="string">&#x27;github.com (IP ADDRESS)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="line"><span class="string">&gt; Are you sure you want to continue connecting (yes/no)?</span></span><br><span class="line"><span class="string"># print yes</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Hi username! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not</span></span><br><span class="line"><span class="string">&gt; provide shell access.</span></span><br></pre></td></tr></table></figure>
<br>

<h3 id="现在可进行关联远程仓库等操作"><a href="#现在可进行关联远程仓库等操作" class="headerlink" title="现在可进行关联远程仓库等操作"></a><em>现在可进行关联远程仓库等操作</em></h3><p>关联远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:&lt;username&gt;/&lt;repositoryName&gt;.git</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>技术随笔</tag>
      </tags>
  </entry>
</search>
